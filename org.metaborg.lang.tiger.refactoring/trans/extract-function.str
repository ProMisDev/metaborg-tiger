module extract-function

imports 
	signatures/-
	nabl2/api
	pp
	libspoofax/stratego/debug
	libstratego-lib
	renaming

rules // menu action strategies

  extract-function-action :
    (selected-term, _, ast, path, project-path) -> (filename, result)
    where
    	analysis := <nabl2-get-ast-analysis> ast;
      <not(nabl2-analysis-has-errors)> analysis
    with
      filename := <guarantee-extension(|"refactored.tig")> path 
      ; selected-list := <make-list> selected-term
      ; <ppdebug(|"Selected list:		")> selected-list
      ; <map(is-exp) <+ (ppdebug(|"Not all selected terms are expressions: ") ; fail)> selected-list
      ; function-name := <read-config-file> ($[[project-path]/[path].rfac], "refactoring.extract")  
      ; new-fun-dec := <create-function(|function-name)> selected-list
      ; first-term := <head> selected-list
      ; target-let := <collect-one(get-surounding-let(|first-term))> ast
      ; <ppdebug(|"target-let")> target-let
      ; ast2 := <oncetd(extract-function(|new-fun-dec, first-term, function-name, selected-list))> ast
      ; <ppdebugna2> ast2
  		; ast3 := <topdown(try(delete-extracted-exp(|selected-list)))> ast2
      ; <ppdebugna3> ast3
      ; result := <pp-Tiger-string> ast3
       	
rules	    
	create-function(|function-name): selected-list -> funDec
  where
    funDec := FunDecs([ProcDec(function-name, [], Seq(selected-list))])
	    
	extract-function(|new-fun-dec, first-term, function-name, selected-list): this-let@Let(decs, exps) -> Let(newDecs, newExps)
	  where
	  	<elem> (first-term, exps)	
	  	;<ppdebug0> "found"
	  	; newExps := <oncetd(insert-call(|first-term, function-name))> exps
	    ; newDecs := <concat> [decs, [new-fun-dec]]
	
	insert-call(|first-term, function-name): term -> Call(function-name, [])
	  where
	    <?term> first-term
	    
	delete-extracted-exp(|selected-list): Let(decs, exps) -> Let(decs, filteredExps)
	    where
	    	filteredExps := <filter(is-extracted-exp(|selected-list))> exps
	    	
	is-extracted-exp(|selected-list): exp -> exp
		where
			<not(elem)> (exp, selected-list)
			
	get-surounding-let(|first-term): Let(decs, exps) -> Let(decs, exps)
		where 
	    <elem> (first-term, exps)	
	    
rules	//is-exp
	is-exp: Let(_,_) -> ()
	is-exp: Array(_, _, _) -> ()
	is-exp: Seq(_) ->  ()
	is-exp: If(_,_,_) -> ()
	is-exp: IfThen(_,_) -> ()
	is-exp: While(_,_) -> ()
	is-exp: For(_,_,_,_) -> ()
	is-exp: Break() -> ()
	is-exp: Call(_,_) -> ()
	is-exp: Int(_) -> ()
	is-exp: Uminus(_) -> ()
	is-exp: Times(_,_) -> ()
	is-exp: Divide(_,_) -> ()
	is-exp: Plus(_,_) -> () 
	is-exp: Minus(_,_) -> ()
	is-exp: Eq(_,_) -> () 
	is-exp: Neq(_,_) -> ()
	is-exp: Gt(_,_) -> () 
	is-exp: Lt(_,_) -> ()  
	is-exp: Geq(_,_) -> () 
	is-exp: Leq(_,_) -> ()  
	is-exp: And(_,_) -> ()
	is-exp: Or(_,_) -> ()   
	is-exp: NilExp() -> ()
	is-exp: Record(_,_) -> ()
	is-exp: String(_) -> ()
	is-exp: Var(_) -> ()
	is-exp: Assign(_,_) -> ()

rules // Utility functions
	make-list: term -> list
	where
		if <?Cons(_,_)> term 
		then list := term
		else list := Cons(term, Nil()) end
		
	head: [head| tail] -> head
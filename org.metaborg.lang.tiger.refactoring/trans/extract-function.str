module extract-function

imports 
	signatures/-
	nabl2/api
	pp
	libspoofax/stratego/debug
	libstratego-lib
	renaming

rules // menu action strategies

  extract-function-action :
    (selected-term, _, ast, path, project-path) -> (filename, result)
    where
    	analysis := <nabl2-get-ast-analysis> ast;
      <not(nabl2-analysis-has-errors)> analysis
    with
      filename := <guarantee-extension(|"refactored.tig")> path 
      ; <ppdebugna(|"Selected term: ")> selected-term
      ; selected-list := <make-list> selected-term
      ; <ppdebugna(|"Selected list:		")> selected-list
      ; <map(is-exp) <+ (ppdebug(|"Not all selected terms are expressions: ") ; fail)> selected-list
      ; function-name := <read-config-file> ($[[project-path]/[path].rfac], "refactoring.extract")  
      ; new-fun-dec := <create-function(|function-name)> selected-list
      ; first-term := <head> selected-list
      ; ast2 := <oncetd(extract-function(|new-fun-dec, first-term, function-name, selected-list))> ast
  		; ast3 := <topdown(try(delete-extracted-exp(|selected-list)))> ast2
      ; result := <pp-Tiger-string> ast3
       	
rules	    
	create-function(|function-name): selected-list -> funDec
  where
    funDec := ProcDec(function-name, [], Seq(selected-list))
	    
	extract-function(|new-fun-dec, first-term, function-name, selected-list): this-let@Let(decs, exps) -> Let(newDecs, newExps)
	  where
	  	<elem> (first-term, exps)	
	  	; newExps := <oncetd(insert-call(|first-term, function-name))> exps
	    ; newDecs := <concat> [decs, [FunDecs([new-fun-dec])]]
	
	extract-function(|new-fun-dec, first-term, function-name, selected-list): FunDecs(decs) -> FunDecs(newDecs)
  where
  	editedDecs := <map(edit-fun-dec(|first-term, function-name, selected-list))> decs
    ; newDecs := <concat> [editedDecs, [new-fun-dec]]
    
  edit-fun-dec(|first-term, function-name, selected-list): FunDec(name, params, type, body) -> FunDec(name, params, type, newBody)
	where
		<ppdebug(|"first-term: ")> first-term;
		if  <oncetd(insert-call(|first-term, function-name))> body
		then newBody := <oncetd(insert-call(|first-term, function-name))> body
		else newBody := body end
		
	edit-fun-dec(|first-term, function-name, selected-list): ProcDec(name, params, body) -> ProcDec(name, params, newBody)
	where
		<ppdebug(|"first-term: ")> first-term;
		if  <oncetd(insert-call(|first-term, function-name))> body
		then newBody := <oncetd(insert-call(|first-term, function-name))> body
		else newBody := body end
		
	insert-call(|first-term, function-name): term -> Call(function-name, [])
	  where
	    <?term> first-term
	    ;<ppdebug0>"found"
	    
	delete-extracted-exp(|selected-list): Let(decs, exps) -> Let(decs, filteredExps)
	    where
	    	filteredExps := <filter(is-extracted-exp(|selected-list))> exps
	    	
	is-extracted-exp(|selected-list): exp -> exp
		where
			<not(elem)> (exp, selected-list)
			
rules	//is-exp
	is-exp: Let(_,_) -> ()
	is-exp: Array(_, _, _) -> ()
	is-exp: Seq(_) ->  ()
	is-exp: If(_,_,_) -> ()
	is-exp: IfThen(_,_) -> ()
	is-exp: While(_,_) -> ()
	is-exp: For(_,_,_,_) -> ()
	is-exp: Break() -> ()
	is-exp: Call(_,_) -> ()
	is-exp: Int(_) -> ()
	is-exp: Uminus(_) -> ()
	is-exp: Times(_,_) -> ()
	is-exp: Divide(_,_) -> ()
	is-exp: Plus(_,_) -> () 
	is-exp: Minus(_,_) -> ()
	is-exp: Eq(_,_) -> () 
	is-exp: Neq(_,_) -> ()
	is-exp: Gt(_,_) -> () 
	is-exp: Lt(_,_) -> ()  
	is-exp: Geq(_,_) -> () 
	is-exp: Leq(_,_) -> ()  
	is-exp: And(_,_) -> ()
	is-exp: Or(_,_) -> ()   
	is-exp: NilExp() -> ()
	is-exp: Record(_,_) -> ()
	is-exp: String(_) -> ()
	is-exp: Var(_) -> ()
	is-exp: Assign(_,_) -> ()

rules // Utility functions
	make-list: term -> list
	where
		if <?Cons(_,_)> term 
		then list := term
		else list := Cons(term, Nil()) end
		
	head: [head| tail] -> head